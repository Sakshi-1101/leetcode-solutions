import java.util.HashMap;

public class CountSubArraySumEqualToK {

    public static void main(String[] args) {

        int[] arr = {3, 1, 2, 4};
        int k = 6;

        int countBrute = countSubarraySumToKBrute(arr, k);
        int countBetter = countSubarraySumToKBetter(arr, k);
        int countOptimal = countSubarraySumToKOptimal(arr, k);

        System.out.println(countBrute);
        System.out.println(countBetter);
        System.out.println(countOptimal);
    }

    // TC: O(N^3)
    // SC: O(1)
    // Approach: We are generating all the subarrays and calculating their sums to check if they are equal to k.
    public static int countSubarraySumToKBrute(int[] arr, int k) {
        int count = 0;

        for(int i = 0 ; i < arr.length ; i ++) {
            for(int j = i ; j < arr.length ; j ++) {
                int sum = 0; 

                // adding the elements of each subarray generated by this loop
                for(int l = i ; l <= j ; l++) {
                    sum += arr[l];
                }

                if(sum == k) {
                    count++;
                }

            }
        } 

        return count;

    }

    // TC: O(N^2)
    // SC: O(1)
    // Approach: In this approach, we are generating all the subarrays but calculating their sums on the go to check if they are equal to k.
    //           In this way we avoid the innermost loop of calculating sum for each subarray.
    public static int countSubarraySumToKBetter(int[] arr, int k) {
        int count = 0;

        for(int i = 0 ; i < arr.length ; i ++) {
            int sum = 0;
            for(int j = i ; j < arr.length ; j ++) {
                sum += arr[j]; // adding the elements for the subarray generated on the go

                if(sum == k) {
                    count++;
                }
            }
        } 

        return count;
    
    }

    // TC: O(N)
    // SC: O(1)
    //   : O(n) In the worst case, all prefix sums are distinct and stored in the hashmap, so space grows linearly with input size.
    // Approach: In this approach, we are using prefix sums and a hashmap to store the frequency of prefix sums.
    //           For each prefix sum, we calculate the remaining sum (prefixSum - k) and check if it exists in the hashmap.
    //           If it exists, we increment the count by the frequency of that remaining sum.
    public static int countSubarraySumToKOptimal(int[] arr, int k) {
        //Map to store frequency of prefix sums
        HashMap<Integer, Integer> map = new HashMap<>();

        // base case: prefix sum=0 has occurred once before starting the array traversal bcoz empty subarray is also a subarray for every array
        map.put(0, 1);

        // Initialize prefix sum and count of subarrays
        int prefixSum = 0;
        int count = 0;
        
        for(int i = 0 ; i < arr.length ; i ++) {
            prefixSum += arr[i];  // Add current element to prefix sum
            
            // Calculate the remaining sum bcoz if there exists a prefix sum equal to remSum, then the subarray between that prefix sum and current prefix sum will have sum equal to k
            int remSum = prefixSum - k; 

            // If remSum exists in map, that means there exists a subarray with sum equal to k
            if(map.containsKey(remSum)){
                count += map.get(remSum); // Increment count by the frequency of remSum
            }

            // Add/updatpe the current prefix sum in the map
            map.put(prefixSum, map.getOrDefault(prefixSum, 0) + 1);
        }

        return count;
    
    }
    
}
